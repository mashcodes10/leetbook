"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[9243],{8791:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>a,toc:()=>m});const a=JSON.parse('{"id":"blind-75/Time Based Key and Value Store","title":"Time Based Key and Value Store","description":"Problem Link https://leetcode.com/problems/time-based-key-value-store/.","source":"@site/docs/blind-75/Time Based Key and Value Store.md","sourceDirName":"blind-75","slug":"/blind-75/Time Based Key and Value Store","permalink":"/docs/blind-75/Time Based Key and Value Store","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/blind-75/Time Based Key and Value Store.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Search Suggestions System","permalink":"/docs/blind-75/Search Suggestions System"},"next":{"title":"Valid Suduko","permalink":"/docs/blind-75/Valid Suduko"}}');var s=n(4848),r=n(8453);const i={sidebar_position:2},o="Time Based Key and Value Store",l={},m=[{value:"Approch and Code",id:"approch-and-code",level:2}];function p(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"time-based-key-and-value-store",children:"Time Based Key and Value Store"})}),"\n",(0,s.jsxs)(t.p,{children:["Problem Link ",(0,s.jsx)(t.a,{href:"https://leetcode.com/problems/time-based-key-value-store/",children:"https://leetcode.com/problems/time-based-key-value-store/"}),"."]}),"\n",(0,s.jsx)(t.h2,{id:"approch-and-code",children:"Approch and Code"}),"\n",(0,s.jsxs)(t.p,{children:["Please look at the ",(0,s.jsx)(t.strong,{children:"approach"})," and the ",(0,s.jsx)(t.code,{children:"solution"})," below."]}),"\n",(0,s.jsx)(t.p,{children:"Add metadata to customize the sidebar label and position:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-md",metastring:'title="memo" {1-4}',children:"---\nProblem: Time-Based Key-Value Store\nObjective: Design a data structure that:\nStores key-value pairs along with timestamps.\nRetrieves the value of a key at a specific timestamp or the most recent value before the given timestamp.\nKey Operations:\nset(key, value, timestamp): Store a key-value pair with a timestamp.\nget(key, timestamp): Retrieve the value of the key at the given timestamp or the most recent value before it.\nInsight\nKey-Value Mapping: Use a dictionary (store) where:\nThe key is the string key.\nThe value is a list of [value, timestamp] pairs.\nBinary Search for Efficiency: Since timestamps are stored in sorted order, use binary search to quickly find the closest timestamp less than or equal to the queried timestamp.\n\nApproach\nData Structure Design:\n\nDictionary (store):\nKeys: Strings representing the keys.\nValues: Lists of [value, timestamp] pairs, sorted by timestamp.\nSetting a Value (set):\n\nIf the key is not in store, initialize it with an empty list.\nAppend the [value, timestamp] pair to the list.\nGetting a Value (get):\n\nUse binary search to find the largest timestamp less than or equal to the queried timestamp:\nInitialize two pointers (l and r) for the search.\nCompute the mid-point (m) and check:\nIf values[m][1] <= timestamp, update the result and search the right half.\nOtherwise, search the left half.\nReturn the result, which is either the closest value or an empty string if no valid timestamp exists.\n\n"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-py",metastring:'title="Solution.py"',children:'class TimeMap:\n\n    def __init__(self):\n        self.store = {} # key :\n\n    def set(self, key: str, value: str, timestamp: int) -> None:\n        if key not in self.store:\n            self.store[key] = [] # create empty list\n        self.store[key].append([value, timestamp])\n\n\n    def get(self, key: str, timestamp: int) -> str:\n        res = ""\n        values = self.store.get(key,[])\n\n        #binary search on the values\n        l,r = 0, len(values) - 1\n        while l <= r:\n            m = (l + r) // 2\n            if values[m][1] <= timestamp:\n                res = values[m][0]\n                l = m + 1\n            else:\n                r = m - 1\n        return res\n\n\n# Your TimeMap object will be instantiated and called as such:\n# obj = TimeMap()\n# obj.set(key,value,timestamp)\n# param_2 = obj.get(key,timestamp)\n        \n'})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-md",metastring:'title="Rundown"',children:'Example Operations\nOperation: set("foo", "bar", 1)\nInput:\nKey: "foo", Value: "bar", Timestamp: 1\nProcess:\n"foo" is not in store. Initialize store["foo"] = [].\nAppend [value="bar", timestamp=1] to store["foo"].\nResult:\nlua\nCopy code\nstore = {\n  "foo": [["bar", 1]]\n}\nOperation: set("foo", "baz", 3)\nInput:\nKey: "foo", Value: "baz", Timestamp: 3\nProcess:\nAppend [value="baz", timestamp=3] to store["foo"].\nResult:\nlua\nCopy code\nstore = {\n  "foo": [["bar", 1], ["baz", 3]]\n}\nOperation: get("foo", 2)\nInput:\nKey: "foo", Timestamp: 2\nProcess:\nRetrieve store["foo"] = [["bar", 1], ["baz", 3]].\nPerform binary search:\nInitial pointers: l=0, r=1\nMidpoint m=0: Check values[0][1]=1. Since 1 <= 2, update res="bar" and set l=1.\nEnd of loop: l=1, r=1. Return res="bar".\nResult: "bar"\nOperation: get("foo", 3)\nInput:\nKey: "foo", Timestamp: 3\nProcess:\nRetrieve store["foo"] = [["bar", 1], ["baz", 3]].\nPerform binary search:\nInitial pointers: l=0, r=1\nMidpoint m=0: Check values[0][1]=1. Since 1 <= 3, update res="bar" and set l=1.\nMidpoint m=1: Check values[1][1]=3. Since 3 <= 3, update res="baz" and set l=2.\nEnd of loop: l=2, r=1. Return res="baz".\nResult: "baz"\nOperation: get("foo", 0)\nInput:\nKey: "foo", Timestamp: 0\nProcess:\nRetrieve store["foo"] = [["bar", 1], ["baz", 3]].\nPerform binary search:\nInitial pointers: l=0, r=1\nMidpoint m=0: Check values[0][1]=1. Since 1 > 0, set r=-1.\nEnd of loop: l=0, r=-1. Return res="".\nResult: ""\nEdge Cases\nNo Entries for Key:\n\nget("bar", 2) \u2192 Key "bar" does not exist in store. Return "".\nTimestamp Smaller than All Stored Timestamps:\n\nIf queried timestamp is smaller than the smallest timestamp for the key, return "".\nExact Match for Timestamp:\n\nBinary search directly finds the timestamp.\nComplexity Analysis\nTime Complexity:\nset(key, value, timestamp):\n\nO(1) to append to the list.\nget(key, timestamp):\n\nO(logN) for binary search, where \nN is the number of entries for the key.\nSpace Complexity:\n\nO(K+V), where K is the number of unique keys, and  V is the total number of key-value-timestamp pairs stored.\nComparison with Alternative Solutions\n1. Linear Search:\nApproach: Perform a linear scan through the list of [value, timestamp] pairs for the queried key.\nAdvantages: Simple to implement.\nDisadvantages: Inefficient for large datasets (\n\nO(N) per query).\n2. Balanced Binary Search Tree:\nApproach: Use a tree-like structure for each key to store [value, timestamp] pairs.\nAdvantages: Efficient lookups (\n\nO(logN)).\nDisadvantages: Higher implementation complexity and space usage compared to a simple list and binary search.\n3. Current Solution (List + Binary Search):\nApproach: Store sorted [value, timestamp] pairs in a list and use binary search for efficient lookups.\nAdvantages:\nSimple to implement.\nEfficient for lookups (O(logN)) and inserts (O(1)).\nDisadvantages:\nAppending timestamps assumes they are always added in increasing order.\n'})})]})}function d(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(p,{...e})}):p(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>o});var a=n(6540);const s={},r=a.createContext(s);function i(e){const t=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),a.createElement(r.Provider,{value:t},e.children)}}}]);