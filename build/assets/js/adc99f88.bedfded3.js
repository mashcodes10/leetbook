"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[8405],{7329:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"blind-75/Merge K Sorted List","title":"Merge K Sorted List","description":"Problem Link https://leetcode.com/problems/merge-k-sorted-lists/description/.","source":"@site/docs/blind-75/Merge K Sorted List.md","sourceDirName":"blind-75","slug":"/blind-75/Merge K Sorted List","permalink":"/docs/blind-75/Merge K Sorted List","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/blind-75/Merge K Sorted List.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"LRU Chache","permalink":"/docs/blind-75/LRU Cache"},"next":{"title":"Min Stack","permalink":"/docs/blind-75/Min Stack"}}');var o=t(4848),i=t(8453);const r={sidebar_position:2},a="Merge K Sorted List",d={},l=[{value:"Approch and Code",id:"approch-and-code",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"merge-k-sorted-list",children:"Merge K Sorted List"})}),"\n",(0,o.jsxs)(n.p,{children:["Problem Link ",(0,o.jsx)(n.a,{href:"https://leetcode.com/problems/merge-k-sorted-lists/description/",children:"https://leetcode.com/problems/merge-k-sorted-lists/description/"}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"approch-and-code",children:"Approch and Code"}),"\n",(0,o.jsxs)(n.p,{children:["Please look at the ",(0,o.jsx)(n.strong,{children:"approach"})," and the ",(0,o.jsx)(n.code,{children:"solution"})," below."]}),"\n",(0,o.jsx)(n.p,{children:"Add metadata to customize the sidebar label and position:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-md",metastring:'title="memo" {1-4}',children:"---\nMerge k Sorted Lists\nInsight: Use a min-heap to efficiently manage merging k lists.\n\nApproach:\n\nPush the head of each list into a min-heap.\nExtract the smallest element, add it to the merged list, and push its next node into the heap.\nRepeat until the heap is empty.\nTime Complexity: \n\nO(nlogk)\n\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-py",metastring:'title="Solution.py"',children:"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        heap = []\n        for i, node in enumerate(lists):\n            if node:\n                heapq.heappush(heap, (node.val, i, node))\n        \n\n        Dummy = ListNode()\n        curr = Dummy\n\n        while heap:\n            val, i, node = heapq.heappop(heap)\n            curr.next = node\n            curr = node\n            node = node.next\n\n            if node:\n                heapq.heappush(heap, (node.val, i, node))\n\n        return Dummy.next\n\n\n        \n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-md",metastring:'title="Rundown"',children:"Execution Trace Example\nInput:\n\ud835\udc58\n=\n3\nk=3, Lists:\nList 1: [1, 4, 7]\nList 2: [2, 5, 6]\nList 3: [3, 8, 9]\nProcess:\nInitial Heap Push:\n\nPush heads of all lists: \n\n(1,0,node1),(2,1,node2),(3,2,node3).\nHeap: [(1, 0, node1), (2, 1, node2), (3, 2, node3)].\nFirst Extraction:\n\nExtract smallest: (1, 0, node1).\nAttach node1 to the merged list.\nPush next node from List 1: (4, 0, node4).\nHeap: [(2, 1, node2), (3, 2, node3), (4, 0, node4)].\nSecond Extraction:\n\nExtract smallest: (2, 1, node2).\nAttach node2 to the merged list.\nPush next node from List 2: (5, 1, node5).\nHeap: [(3, 2, node3), (4, 0, node4), (5, 1, node5)].\nThird Extraction:\n\nExtract smallest: (3, 2, node3).\nAttach node3 to the merged list.\nPush next node from List 3: (8, 2, node8).\nHeap: [(4, 0, node4), (5, 1, node5), (8, 2, node8)].\nContinue Extracting:\n\nRepeat the process until the heap is empty.\nFinal Merged List:\n[1 \u2192 2 \u2192 3 \u2192 4 \u2192 5 \u2192 6 \u2192 7 \u2192 8 \u2192 9]\n\n\nKey Intuition\nThe min-heap ensures that only the smallest element across all lists is processed at each step, maintaining the sorted order efficiently.\nBy pushing the next node from the list of the extracted node, the heap always contains one element from each active list.\n\n"})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var s=t(6540);const o={},i=s.createContext(o);function r(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);