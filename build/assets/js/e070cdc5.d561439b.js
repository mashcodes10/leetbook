"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[780],{219:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>a,contentTitle:()=>s,default:()=>h,frontMatter:()=>i,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"blind-75/Word Ladder","title":"Word Ladder","description":"Problem Link https://leetcode.com/problems/word-ladder/.","source":"@site/docs/blind-75/Word Ladder.md","sourceDirName":"blind-75","slug":"/blind-75/Word Ladder","permalink":"/docs/blind-75/Word Ladder","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/blind-75/Word Ladder.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Valid Suduko","permalink":"/docs/blind-75/Valid Suduko"},"next":{"title":"Word Search","permalink":"/docs/blind-75/Word Search"}}');var r=o(4848),d=o(8453);const i={sidebar_position:2},s="Word Ladder",a={},c=[{value:"Approch and Code",id:"approch-and-code",level:2}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",strong:"strong",...(0,d.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"word-ladder",children:"Word Ladder"})}),"\n",(0,r.jsxs)(n.p,{children:["Problem Link ",(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/word-ladder/",children:"https://leetcode.com/problems/word-ladder/"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"approch-and-code",children:"Approch and Code"}),"\n",(0,r.jsxs)(n.p,{children:["Please look at the ",(0,r.jsx)(n.strong,{children:"approach"})," and the ",(0,r.jsx)(n.code,{children:"solution"})," below."]}),"\n",(0,r.jsx)(n.p,{children:"Add metadata to customize the sidebar label and position:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-md",metastring:'title="memo" {1-4}',children:'---\nProblem: Word Ladder\nObjective: Given a beginWord, endWord, and a wordList, find the shortest transformation sequence from beginWord to endWord such that:\nOnly one letter can change at a time.\nEach transformed word must exist in the wordList.\nKey Operations:\nRepresent words as nodes in a graph, where edges exist between words that differ by one character.\nPerform BFS to find the shortest path from beginWord to endWord.\nInsight\nGraph Representation:\n\nTreat each word as a node.\nWords are connected if they differ by exactly one character.\nExample: ["hit", "hot", "dot", "dog", "cog"] can be visualized as:\nCopy code\nhit \u2192 hot \u2192 dot \u2192 dog \u2192 cog\nBFS for Shortest Path:\n\nBFS ensures that the shortest path is found first.\nUse a queue to explore each word and its neighbors iteratively.\nApproach\nPreprocess Word List:\n\nConvert the wordList into a set for \n\nO(1) lookups.\nBFS Initialization:\n\nUse a queue initialized with (beginWord, steps) where steps = 1.\nKeep track of visited words to avoid cycles.\nBFS Execution:\n\nFor each word, generate all possible one-character transformations.\nIf a transformation is in the wordList, add it to the queue and mark it as visited.\nStop if endWord is reached.\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-py",metastring:'title="Solution.py"',children:"from collections import deque\nclass Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\n        q = deque ([(beginWord, 1)])\n        wordSet = set(wordList)\n        wordSet.discard(beginWord)\n\n        if endWord not in wordList:\n            return 0\n        \n        while q:\n            word, step = q.popleft()\n            \n            #first check the base case if it is the target or endWord\n            if word == endWord:\n                return step\n            \n            for i in range(len(word)):\n                #replace the chars \n                orig_char = word[i]\n                for char in (chr(i) for i in range(97,123)) : #26 letters\n                    \n                    transformed_word = word[:i] + char + word[i+1:]\n                    if transformed_word in wordSet:\n                        wordSet.remove(transformed_word)\n                        q.append((transformed_word, step + 1))\n                word = word[:i] + orig_char + word[i+1:]\n\n        return 0\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-md",metastring:'title="Rundown"',children:'Visual Explanation\nExample Input\nInput:\n\nmakefile\nCopy code\nbeginWord = "hit"\nendWord = "cog"\nwordList = ["hot", "dot", "dog", "lot", "log", "cog"]\nExecution\nPreprocess Word List:\n\nmakefile\nCopy code\nwordSet = {"hot", "dot", "dog", "lot", "log", "cog"}\nBFS Execution:\n\nStep 1:\n\nQueue: [("hit", 1)]\nNeighbors of "hit":\n"hot" is valid (exists in wordSet).\nAdd "hot" to the queue: [("hot", 2)].\nRemove "hot" from wordSet.\nStep 2:\n\nQueue: [("hot", 2)]\nNeighbors of "hot":\n"dot" and "lot" are valid.\nAdd "dot" and "lot" to the queue: [("dot", 3), ("lot", 3)].\nRemove "dot" and "lot" from wordSet.\nStep 3:\n\nQueue: [("dot", 3), ("lot", 3)]\nNeighbors of "dot":\n"dog" is valid.\nAdd "dog" to the queue: [("lot", 3), ("dog", 4)].\nRemove "dog" from wordSet.\nStep 4:\n\nQueue: [("lot", 3), ("dog", 4)]\nNeighbors of "lot":\n"log" is valid.\nAdd "log" to the queue: [("dog", 4), ("log", 4)].\nRemove "log" from wordSet.\nStep 5:\n\nQueue: [("dog", 4), ("log", 4)]\nNeighbors of "dog":\n"cog" is valid.\nAdd "cog" to the queue: [("log", 4), ("cog", 5)].\nRemove "cog" from wordSet.\nStep 6:\n\nQueue: [("log", 4), ("cog", 5)]\n"cog" is reached. Return steps = 5.\nResult\nThe shortest transformation sequence length is 5: ["hit" \u2192 "hot" \u2192 "dot" \u2192 "dog" \u2192 "cog"].\n\nComplexity Analysis\nTime Complexity\nWord Transformations:\nFor each word of length \n\nL, generate  26\xd7L transformations.\nTotal transformations: \n\nO(N\u22c5L\u22c526), where \n\nN is the number of words in the list.\nBFS:\nEach word is visited once. Each neighbor lookup is \n\nO(L\u22c526).\nOverall complexity: \n\nO(N\u22c5L 2).\nSpace Complexity\nQueue and visited set store up to \n\nO(N) words.\nTotal space: \n\nO(N\u22c5L), where \n\nL is the word length.\nEdge Cases\nNo Path Exists:\nIf endWord is not in wordList, return 0.\nIdentical Words:\nIf beginWord == endWord, return 1.\nEmpty Word List:\nReturn 0.\n'})})]})}function h(e={}){const{wrapper:n}={...(0,d.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},8453:(e,n,o)=>{o.d(n,{R:()=>i,x:()=>s});var t=o(6540);const r={},d=t.createContext(r);function i(e){const n=t.useContext(d);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),t.createElement(d.Provider,{value:n},e.children)}}}]);