"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[4233],{9326:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"blind-75/Word Search","title":"Word Search","description":"Problem Link https://leetcode.com/problems/word-search/description/.","source":"@site/docs/blind-75/Word Search.md","sourceDirName":"blind-75","slug":"/blind-75/Word Search","permalink":"/docs/blind-75/Word Search","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/blind-75/Word Search.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Word Ladder","permalink":"/docs/blind-75/Word Ladder"},"next":{"title":"Course Schedule II","permalink":"/docs/blind-75/course-schedule-II"}}');var o=r(4848),s=r(8453);const i={sidebar_position:2},a="Word Search",d={},c=[{value:"Approch and Code",id:"approch-and-code",level:2}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"word-search",children:"Word Search"})}),"\n",(0,o.jsxs)(n.p,{children:["Problem Link ",(0,o.jsx)(n.a,{href:"https://leetcode.com/problems/word-search/description/",children:"https://leetcode.com/problems/word-search/description/"}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"approch-and-code",children:"Approch and Code"}),"\n",(0,o.jsxs)(n.p,{children:["Please look at the ",(0,o.jsx)(n.strong,{children:"approach"})," and the ",(0,o.jsx)(n.code,{children:"solution"})," below."]}),"\n",(0,o.jsx)(n.p,{children:"Add metadata to customize the sidebar label and position:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-md",metastring:'title="memo" {1-4}',children:"---\nWord Search\nInsight: Use DFS to explore all possible paths for matching a word.\n\nApproach:\n\nDefine a DFS function:\nBase case: Return true if the word is fully matched.\nMark cells as visited to avoid revisits.\nExplore neighbors (up, down, left, right).\nBacktrack after the recursive calls.\nTime Complexity: \n\nO(N\u22c53 ^L)\n\nL is the word length.\n\n\n\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-py",metastring:'title="Solution.py"',children:"class Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        ROWS, COLS = len(board), len(board[0])\n        n = len(word)\n        path = set()\n\n        def dfs(r,c,i): #n= current index of the word\n            if i == n: # the current index of the word is the last index\n                return True\n            if(r < 0 or c < 0 or r >= ROWS or c >= COLS or word[i] != board[r][c] or (r,c) in path):\n                return False \n            # we found a charcter that we need \n            path.add((r,c))\n\n            #recursive backtracking- any of them finds the word it returns true\n            result = (dfs(r+1, c, i+1) or\n             dfs(r-1, c, i+1) or\n             dfs(r, c+1, i+1) or\n             dfs(r, c-1, i+1) )\n            \n            path.remove((r,c))\n            return result  \n        #bruteforce run through entire board\n        for rows in range(ROWS):\n            for cols in range(COLS):\n                if dfs(rows,cols,0): #if our dfs ever returns true, that means word is found\n                    return True\n        \n        return False\n\n        \n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-md",metastring:'title="Rundown"',children:'Execution Trace Example\nInput:\nGrid:\n\nC A T\nD E F\nG H I\n\nWord: "CAT"\nProcess:\nStart DFS from C (0, 0):\n\nMatch first letter "C".\nMark (0, 0) as visited. path = {(0, 0)}.\nExplore neighbors:\nDown to D: No match.\nRight to A: Match second letter.\nMove to A (0, 1):\n\nMatch second letter "A".\nMark (0, 1) as visited. path = {(0, 0), (0, 1)}.\nExplore neighbors:\nDown to E: No match.\nRight to T: Match third letter.\nMove to T (0, 2):\n\nMatch third letter "T".\nMark (0, 2) as visited. path = {(0, 0), (0, 1), (0, 2)}.\nWord found since i == len(word). Return True.\nKey Intuition\nRecursive Exploration: Each DFS call explores all possible paths starting from the current cell.\nBacktracking: After exploring a path, the cell is unmarked to allow exploration of other potential paths.\nEfficiency: The path set prevents revisiting cells and invalid paths.\nComplexity\nTime Complexity: \n\nO(N\u22c53 ^L), where:\n\nN: Number of cells in the grid.\n\nL: Length of the word.\nEach cell has up to 3 unvisited neighbors to explore.\nSpace Complexity: \n\nO(L), due to the recursion stack and path storage\n\n\n'})})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>a});var t=r(6540);const o={},s=t.createContext(o);function i(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);