"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[1168],{5809:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>r,contentTitle:()=>c,default:()=>p,frontMatter:()=>o,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"blind-75/Min Stack","title":"Min Stack","description":"Problem Link https://leetcode.com/problems/min-stack/description/.","source":"@site/docs/blind-75/Min Stack.md","sourceDirName":"blind-75","slug":"/blind-75/Min Stack","permalink":"/docs/blind-75/Min Stack","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/blind-75/Min Stack.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Merge K Sorted List","permalink":"/docs/blind-75/Merge K Sorted List"},"next":{"title":"Reorder Data In Log Files","permalink":"/docs/blind-75/Reorder Data In Log Files"}}');var s=t(4848),a=t(8453);const o={sidebar_position:2},c="Min Stack",r={},l=[{value:"Approch and Code",id:"approch-and-code",level:2}];function m(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"min-stack",children:"Min Stack"})}),"\n",(0,s.jsxs)(e.p,{children:["Problem Link ",(0,s.jsx)(e.a,{href:"https://leetcode.com/problems/min-stack/description/",children:"https://leetcode.com/problems/min-stack/description/"}),"."]}),"\n",(0,s.jsx)(e.h2,{id:"approch-and-code",children:"Approch and Code"}),"\n",(0,s.jsxs)(e.p,{children:["Please look at the ",(0,s.jsx)(e.strong,{children:"approach"})," and the ",(0,s.jsx)(e.code,{children:"solution"})," below."]}),"\n",(0,s.jsx)(e.p,{children:"Add metadata to customize the sidebar label and position:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-md",metastring:'title="memo" {1-4}',children:"---\nMin Stack\nInsight: Use a secondary stack to keep track of the minimum.\n\nApproach:\n\nPush values onto the main stack.\nPush to the min stack only if the value is smaller or equal to the current minimum.\nDuring pop:\nRemove from the min stack if the top matches the popped value.\nTime Complexity: \n\nO(1)\n\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-py",metastring:'title="Solution.py"',children:"class MinStack:\n\n    def __init__(self):\n        self.stack = []\n        self.min_stack = []\n\n    def push(self, val: int) -> None:\n        #our approach is only put the value in the min stack if it is min\n        self.stack.append(val)\n\n        if not self.min_stack:\n            self.min_stack.append(val)\n        elif self.min_stack[-1] < val:\n            self.min_stack.append(self.min_stack[-1])\n        else:\n            self.min_stack.append(val)\n\n    def pop(self) -> None:\n        self.stack.pop()\n        self.min_stack.pop()\n\n    def top(self) -> int:\n        return self.stack[-1]\n\n    def getMin(self) -> int:\n        return self.min_stack[-1]\n\n\n# Your MinStack object will be instantiated and called as such:\n# obj = MinStack()\n# obj.push(val)\n# obj.pop()\n# param_3 = obj.top()\n# param_4 = obj.getMin()\n        \n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-md",metastring:'title="Rundown"',children:"Execution Trace Example\nOperations:\nPush: push(5), push(2), push(8), push(1)\nGet Minimum: getMin()\nPop: pop()\nGet Minimum: getMin()\nProcess:\nInitial State:\n\nstack = []\nminStack = []\nPush 5:\n\nstack = [5]\nminStack = [5] (5 is the minimum).\nPush 2:\n\nstack = [5, 2]\nminStack = [5, 2] (2 is the new minimum).\nPush 8:\n\nstack = [5, 2, 8]\nminStack = [5, 2] (minimum remains 2).\nPush 1:\n\nstack = [5, 2, 8, 1]\nminStack = [5, 2, 1] (1 is the new minimum).\nGet Minimum:\n\ngetMin() = 1 (top of minStack).\nPop:\n\nPop top of stack: 1.\nstack = [5, 2, 8]\nSince \n1\n=\nminStack[-1]\n1=minStack[-1], also pop from minStack.\nminStack = [5, 2].\nGet Minimum:\n\ngetMin() = 2 (top of minStack).\nKey Intuition\nThe minStack mirrors the main stack but only updates when the current value is smaller or equal to the current minimum.\nBy synchronizing the two stacks, we ensure that getMin() is \n\nO(1).\nComplexity\nTime Complexity:\nAll operations (push, pop, top, getMin) are \n\nO(1).\nSpace Complexity:\n\nO(n), where \n\nn is the number of elements pushed onto the stack, as both stacks grow simultaneously.\n\n"})})]})}function p(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(m,{...n})}):m(n)}},8453:(n,e,t)=>{t.d(e,{R:()=>o,x:()=>c});var i=t(6540);const s={},a=i.createContext(s);function o(n){const e=i.useContext(a);return i.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function c(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:o(n.components),i.createElement(a.Provider,{value:e},n.children)}}}]);