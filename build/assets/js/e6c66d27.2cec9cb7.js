"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[6730],{8576:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>m,frontMatter:()=>a,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"blind-75/Search Suggestions System","title":"Search Suggestions System","description":"Problem Link https://leetcode.com/problems/search-suggestions-system/.","source":"@site/docs/blind-75/Search Suggestions System.md","sourceDirName":"blind-75","slug":"/blind-75/Search Suggestions System","permalink":"/docs/blind-75/Search Suggestions System","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/blind-75/Search Suggestions System.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Reorder Data In Log Files","permalink":"/docs/blind-75/Reorder Data In Log Files"},"next":{"title":"Time Based Key and Value Store","permalink":"/docs/blind-75/Time Based Key and Value Store"}}');var s=t(4848),r=t(8453);const a={sidebar_position:2},i="Search Suggestions System",c={},d=[{value:"Approch and Code",id:"approch-and-code",level:2}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"search-suggestions-system",children:"Search Suggestions System"})}),"\n",(0,s.jsxs)(n.p,{children:["Problem Link ",(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/search-suggestions-system/",children:"https://leetcode.com/problems/search-suggestions-system/"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"approch-and-code",children:"Approch and Code"}),"\n",(0,s.jsxs)(n.p,{children:["Please look at the ",(0,s.jsx)(n.strong,{children:"approach"})," and the ",(0,s.jsx)(n.code,{children:"solution"})," below."]}),"\n",(0,s.jsx)(n.p,{children:"Add metadata to customize the sidebar label and position:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-md",metastring:'title="memo" {1-4}',children:'---\nApproach and Insight\nProblem: Group Anagrams\nObjective: Given a list of strings, group them into categories where all strings in a group are anagrams of each other.\nKey Operations:\nGroup words by their sorted character sequence (canonical form).\nUse a hash map to store groups of anagrams.\nInsight\nCanonical Form of Anagrams:\nSorting the characters of each word transforms all anagrams into the same canonical form.\nExample: For "eat", "tea", and "ate", their sorted form is "aet".\nEfficient Grouping:\nUse a dictionary where:\nThe key is the canonical form.\nThe value is a list of all words matching that canonical form.\nApproach\nSort and Map:\n\nFor each word, compute its sorted form.\nUse the sorted form as a key in a dictionary.\nAppend the original word to the list corresponding to that key.\nReturn Groups:\n\nReturn all the lists from the dictionary as the grouped anagrams.\n\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-py",metastring:'title="Solution.py"',children:"class Solution:\n    def suggestedProducts(self, products: List[str], searchWord: str) -> List[List[str]]:\n        products.sort()\n\n        l, r = 0, len(products) - 1\n        res = []\n\n        for i in range (len(searchWord)):\n\n            ch = searchWord[i]\n            \n\n            #Eliminate the words that are not matched with prefix\n\n            while l <= r and  (len(products[l]) <= i or products[l][i] != ch):\n                l += 1 \n            while l <= r and  (len(products[r]) <= i or products[r][i] != ch):\n                r -= 1 \n\n            remainingWords = r - l + 1\n            res.append([])\n\n            #return the list in max of 3\n            for j in range(min(3,remainingWords)):\n                res[-1].append(products[l + j])\n        \n        return res\n        \n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-md",metastring:'title="Rundown"',children:'Visual Explanation\nExample Input\nProducts: ["mobile", "mouse", "moneypot", "monitor", "mousepad"]\nSearch Word: "mouse"\nExecution\nSorted Products:\n\ncss\nCopy code\n["mobile", "moneypot", "monitor", "mouse", "mousepad"]\nPrefix 1: "m"\n\nMatches: All products.\nSuggestions: ["mobile", "moneypot", "monitor"].\nPrefix 2: "mo"\n\nMatches: ["mobile", "moneypot", "monitor", "mouse", "mousepad"].\nSuggestions: ["mobile", "moneypot", "monitor"].\nPrefix 3: "mou"\n\nMatches: ["mouse", "mousepad"].\nSuggestions: ["mouse", "mousepad"].\nPrefix 4: "mous"\n\nMatches: ["mouse", "mousepad"].\nSuggestions: ["mouse", "mousepad"].\nPrefix 5: "mouse"\n\nMatches: ["mouse", "mousepad"].\nSuggestions: ["mouse", "mousepad"].\nComplexity Analysis\nTime Complexity\nSorting: \n\nO(PlogP), where \n\ud835\udc43\nP is the number of products.\nPrefix Search:\nFor each prefix, \n\nO(P) in the worst case (linear scan with two pointers).\nOptimized to \n\nO(logP) per prefix using binary search.\nSpace Complexity\n\nO(P) for storing the sorted products.\nComparison with Alternative Solutions\n1. Trie-Based Solution\nApproach: Store products in a Trie. Traverse the Trie to find matching products for each prefix.\nAdvantages:\nEfficient prefix search (\n\nO(L), where \nL is the length of the prefix).\nDisadvantages:\nHigher space usage due to the Trie structure.\nImplementation complexity is higher than sorting + two-pointer.\n2. Two-Pointer (Current Solution)\nApproach: Use sorted products and adjust pointers for each prefix.\nAdvantages:\nSimpler implementation.\nLeverages sorted products to reduce complexity.\nDisadvantages:\nLess efficient for extremely large product lists or long prefixes.\n'})})]})}function m(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>i});var o=t(6540);const s={},r=o.createContext(s);function a(e){const n=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),o.createElement(r.Provider,{value:n},e.children)}}}]);